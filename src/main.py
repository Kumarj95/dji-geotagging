'''Standalone file to geotag videos given a log file, and SRT file(s) both generated by DJI drones'''
import pandas as pd

import numpy as np
from zoneinfo import ZoneInfo
from dateutil import parser as p
from datetime import timedelta
import os
from glob import glob
from tqdm import tqdm
import json
from geographiclib.geodesic import Geodesic
from scipy.spatial.transform import Rotation as Rot
from scipy.spatial.transform import Slerp
import cv2
from pathlib import Path
import subprocess
from argparse import ArgumentParser

def to_dms_rational(deg):
    '''
    Helper function to convert value from degrees to degree minute seconds

    Args:
        deg (float): angle in degrees to convert

    Returns:
        dms (list): list in format () 
    '''
    d = int(abs(deg))
    m = int((abs(deg)-d)*60)
    s = (abs(deg)-d-m/60)*3600
    return [(d,1),(m,1),(int(s*100),100)]

def R_z(angle):
    '''
    Helper function to create a matrix for rotation around the Z axis
    
    Args:
        angle (float): angle in radians around which to rotate

    Returns:
        R_z (np.array): Rotation matrix about the Z axis with given angle
    '''
    return np.array([[np.cos(angle),-np.sin(angle),0],
                     [np.sin(angle), np.cos(angle),0],
                     [0,0,1                 ]])
def R_y(angle):
    '''
    Helper function to create a matrix for rotation around the Y axis
    
    Args:
        angle (float): angle in radians around which to rotate

    Returns:
        R_y (np.array): Rotation matrix about the Y axis with given angle
    '''

    return np.array([[np.cos(angle),0,np.sin(angle)],
                     [0, 1,0],
                     [-np.sin(angle),0,np.cos(angle)                 ]])

def R_x(angle):
    '''
    Helper function to create a matrix for rotation around the X axis
    
    Args:
        angle (float): angle in radians around which to rotate

    Returns:
        R_x (np.array): Rotation matrix about the X axis with given angle
    '''


    return np.array([[1,0,0],
                     [0, np.cos(angle),-np.sin(angle)],
                     [0,np.sin(angle),np.cos(angle)                 ]])


# Class to do geotagging, pass in the log file (parsed via airdata or something similar) along with the SRT files corresponding to the video
class GeoTagger:

    def __init__(self, log_path, srt_paths, video_dir=None, timezone="America/Toronto", target_gimbal=-69, fps=30, frame_index=1, log_file_row_index=None):
        ''' Initializes an object to do GeoTagging with

        Args:
            log_path (str): Path to log file
            srt_paths (list | str) : list of paths to SRT files OR a directory containing SRT files 
            video_dirs (str): A path to a directory containing the videos 
            timezone (str): timezone to convert UTC timestamps to
            target_gimbal (int): gimbal angle for recording; this is an important cue to do geotagging
            fps (float): the frame rate of the SRT files/ Video
            frame_index (int): First usable frame from the video (first frame where visually the camera pitch looks correct)
            log_file_row_index (int): If you want to use a predefined log file row as the synced row 

        '''
        # Read log file into dataframe (should be in csv format)
        self.logdf= pd.read_csv(log_path)
        self.timezone=ZoneInfo(timezone)
        self.srt_files=[]
        self.video_numbers=[]
        self.video_names=[]
        self.video_paths=[]

        self.target_gimbal= target_gimbal
        self.fps=fps    
        self.frame_index=frame_index

        self.logdf=self.logdf.rename(columns=lambda x: x.strip())
        self.log_start= p.parse(self.logdf.iloc[0]['datetime(utc)']).replace(tzinfo=ZoneInfo('UTC')).astimezone(self.timezone)
        self.log_end= p.parse(self.logdf.iloc[-1]['datetime(utc)']).replace(tzinfo=ZoneInfo('UTC')).astimezone(self.timezone)
        
        # if it is a list of paths, parse each directly
        if(type(srt_paths) == list):
            for srt_file in srt_paths:
                srt_time= p.parse(os.path.basename(srt_file).split('_')[1]).astimezone(self.timezone)
                if(srt_time> self.log_start and srt_time< self.log_end):
                    self.video_numbers.append(int(srt_file.split("_")[3]))
                    self.srt_files.append(self.parse_srt(srt_file))
                    video_name=os.path.splitext(os.path.basename(srt_file))[0]
                    self.video_names.append(video_name)
                    if(video_dir is not None):
                        self.video_paths.append(os.path.join(video_dir,  f"{video_name}.MP4"))
                else:
                    print(f"SRT file {srt_file} does not correspond with log file {log_path}")
        else:
        #if its a directory find the SRT files that match the log file based on time (SRT files have times in the name of the file by default)            
            if(os.path.exists(srt_paths)):
                all_srt_files=glob(f"{srt_paths}/*.SRT")
                all_srt_times=[p.parse(os.path.basename(srt_file).split('_')[1]).astimezone(self.timezone) for srt_file in all_srt_files]
                all_srt_files = [x for x,_ in sorted(zip(all_srt_files,all_srt_times))]
                all_srt_times=sorted(all_srt_times)
                self.srt_files=[]

                for srt_file, srt_time in zip(all_srt_files, all_srt_times):
                    if(srt_time> self.log_start and srt_time< self.log_end):
                        self.video_numbers.append(int(srt_file.split("_")[3]))
                        self.srt_files.append(self.parse_srt(srt_file))
                        video_name=os.path.splitext(os.path.basename(srt_file))[0]
                        self.video_names.append(video_name)
                        if(video_dir is not None):
                            self.video_paths.append(os.path.join(video_dir, f"{video_name}.MP4"))

            else:
                print(f"No such path {srt_paths}")

        if(log_file_row_index is None):
            self.log_file_row_index=self.sync_first_frame()
        else:
            self.log_file_row_index=log_file_row_index
        
        
        # print(self.log_file_row_index)

    def parse_srt(self, filepath):
        ''' 
        Parses the SRT file and stores it into a dataframe for easy use (Only for DJI mini pro 4 SRT files)

        Args:
            filepath (str|path) : path to the SRT file
        
        Returns:
            srt_df (pd.Dataframe): a dataframe containing the information of the SRT file
        '''
        information=[]
        with open(filepath, 'r') as f:
            lines= f.read().split('\n\n')
        columns=''
        for line in lines:
            if(len(line)>0):
                fn,time_interval, frame_info, date_time, image_info= line.split("\n")
                columns= [s[1:-1] if '[' in s else s[:-1] for s in image_info.split(" ")[0:-1:2]  ]
                img_info= [s[:-1] if ']' in s else s for s in image_info.split(" ")[1::2]  ]
                information.append(np.asarray([np.int64(fn),date_time, *img_info ]))
        self.information= np.asarray(information)
        df= pd.DataFrame(information, columns=['fn','timestamp', *columns])
        self.df=df
        return df

    
    #TODO: Write a method to sync the first usable frame of the video to a corresponding row in the log file
    def sync_first_frame(self, threshold=0.001):
        ''' Syncs the first frame of the first SRT file with the target_gimbal angle to a row in the log file

        Due to timestamp offsets in the SRT files and the LogFiles, to sync the two we rely on computing the haversine distance between the latitude-longitude in the SRT file and the LogFile.
        This combined with the gimbal_pitch(degrees) column in the LogFiles gives us a good cue for the approximate correct location.
        There is also an isVideo column in the log file not used here but could be.

        This method is quite hueristic and should be improved


        Args:
            threshold (float): distance threshold for which we consider two positions matching
        Returns:
            Log_index (int): index of the first row of the LogFile to use
        '''

        # We only care about the first SRT file here 
        srt_df=self.srt_files[0]

        # Get first useful position tuple from SRT file, we will use this to match locations from the log file
        first_lat,first_lon = srt_df.iloc[self.frame_index-1]['latitude'],srt_df.iloc[0]['longitude']

        #Convert lat lon to radians
        first_point=np.deg2rad(np.asarray([first_lat, first_lon], dtype=np.float64))

        #Get all positions in the log file
        positions=self.logdf[["latitude", 'longitude']].to_numpy()
        positions= np.deg2rad(positions)

        # Compute distances
        delta_lat= (positions[:,0] - first_point[0])
        delta_lon= (positions[:,1] - first_point[1])
        a = np.sin(delta_lat/2)**2 + (np.cos(positions[:,0]) * np.cos(first_point[0]) * np.sin(delta_lon/2)**2)
        c= 2*np.atan2(np.sqrt(a), np.sqrt(1-a))
        d= 6371*c

        #Round to the same significant figures as the SRT data
        d=np.round(d, len(first_lat.split(".")[-1]))


        # Match positions with threshold only in first half of log file (just in case we return to the starting position in second half of the flight)
        matching_positions=np.where(np.abs(d[:len(d)//2])<threshold)[0]

        # In the matching positions find the first position that matches the target_gimbal angle

        log_file_row_index=(self.logdf.iloc[matching_positions]['gimbal_pitch(degrees)']==self.target_gimbal).idxmax()


        return log_file_row_index





    #TODO: Write a method to interpolate the log file to have one entry per frame (get frame by frame lat, lon, altitude, pitch, yaw, roll)

    def interpolate_rotation_angles(self, target_frequency=30):
        ''' The SRT file contains latitude, longitude and altitude information already we just have to add interpolated rotation angles for both the drone body and the gimbal (yaw, pitch, roll), from the log file
        Args:
            target_frequency (int): How many samples per second we would like the interpolated DF to have (should be equal to the FPS)

        Return: 
            df_interpolated (pd.Dataframe): The logfile DF interpolated to target_frequency samples per second
        '''

        first_time = p.parse(self.logdf.iloc[0]['datetime(utc)']).replace(tzinfo=ZoneInfo('UTC')).astimezone(self.timezone)
        

        for i,row in self.logdf.iterrows():
            if(p.parse(row['datetime(utc)']).replace(tzinfo=ZoneInfo('UTC')).astimezone(self.timezone) != first_time):
                second_time=p.parse(row['datetime(utc)']).replace(tzinfo=ZoneInfo('UTC')).astimezone(self.timezone)
                break
        
        start_time= second_time - timedelta(milliseconds=np.float64(row['time(millisecond)']))
        output_arr=[]
        diff= 1/target_frequency


        for i in tqdm(range(len(self.logdf)-1)):
            current_row= self.logdf.iloc[i]
            next_row=self.logdf.iloc[i+1]
            current_row_datetime=start_time + timedelta(milliseconds= np.float64(current_row['time(millisecond)']))

            lat0, lon0, alt0, relalt0= current_row['latitude'], current_row['longitude'], current_row['altitude_above_seaLevel(meters)'], current_row['height_above_takeoff(meters)']
            lat1, lon1, alt1, relalt1= next_row['latitude'], next_row['longitude'], next_row['altitude_above_seaLevel(meters)'], next_row['height_above_takeoff(meters)']
            g = Geodesic.WGS84.Inverse(lat0, lon0, lat1, lon1)
            line = Geodesic.WGS84.Line(lat0, lon0, g['azi1'])
            time_diff= (next_row['time(millisecond)'] - current_row['time(millisecond)'])/1000
            # f= (frame_offset-start_time)/ (end_time-start_time)
            if(time_diff> diff):
                num_points = (time_diff/diff) 

                #Dont want to resample first element
                if(i!=0):
                    sampling_points= np.linspace(0,1,int(num_points)+1)[1:]
                else:
                    sampling_points= np.linspace(0,1,int(num_points)+1)

                positions = [line.Position(f * g['s12']) for f in sampling_points]  


                d_h0, g_p0, g_r0= np.deg2rad(current_row['compass_heading(degrees)']), np.deg2rad(current_row['pitch(degrees)']) , np.deg2rad(current_row['roll(degrees)'])
                r0 = R_z(d_h0)@ R_y(g_p0) @ R_x(g_r0)


                d_h1, g_p1, g_r1= np.deg2rad(next_row['compass_heading(degrees)']), np.deg2rad(next_row['pitch(degrees)']) , np.deg2rad(next_row['roll(degrees)'])
                r1 = R_z(d_h1)@ R_y(g_p1) @ R_x(g_r1)

                key_rots= Rot.from_matrix([r0, r1])
                slerp=Slerp([0, 1], key_rots)
                rotations= [ i.as_matrix() for i in slerp(sampling_points)]
                angles_flight=[[np.rad2deg(np.atan2(R[1,0],R[0,0])),  np.rad2deg(np.atan2(-R[2,0],np.sqrt(R[2,1]**2+R[2,2]**2))), np.rad2deg(np.atan2(R[2,1],R[2,2]))] for R in rotations]

                d_h0, g_p0, g_r0= np.deg2rad(current_row['gimbal_heading(degrees)']), np.deg2rad(current_row['gimbal_pitch(degrees)']) , np.deg2rad(current_row['gimbal_roll(degrees)'])
                r0 = R_z(d_h0)@ R_y(g_p0) @ R_x(g_r0)


                d_h1, g_p1, g_r1= np.deg2rad(next_row['gimbal_heading(degrees)']), np.deg2rad(next_row['gimbal_pitch(degrees)']) , np.deg2rad(next_row['gimbal_roll(degrees)'])
                r1 = R_z(d_h1)@ R_y(g_p1) @ R_x(g_r1)

                key_rots= Rot.from_matrix([r0, r1])
                slerp=Slerp([0, 1], key_rots)
                rotations= [ i.as_matrix() for i in slerp(sampling_points)]
                angles_gimbal=[[np.rad2deg(np.atan2(R[1,0],R[0,0])),  np.rad2deg(np.atan2(-R[2,0],np.sqrt(R[2,1]**2+R[2,2]**2))), np.rad2deg(np.atan2(R[2,1],R[2,2]))] for R in rotations]


                times= (sampling_points * time_diff*1000) + current_row['time(millisecond)']
                datetimes =[current_row_datetime + timedelta(milliseconds=t) for t in times]   

                altitudes =  (sampling_points* (alt1-alt0)) + alt0
                
                flycstates = [current_row['flycState'] for i in sampling_points]
                for position,altitude, angle_flight, time, datetime,flycstate, angle_gimbal in zip(positions, altitudes, angles_flight, times, datetimes, flycstates, angles_gimbal):
                    output_arr.append([time.item(), datetime, position['lat1'].item(), position['lon1'], altitude.item(), angle_flight[0].item(), angle_flight[1].item(), angle_flight[2].item(),  angle_gimbal[0].item(), angle_gimbal[1].item(), angle_gimbal[2].item(),flycstate])
        df_interpolated= pd.DataFrame(output_arr, columns=['time','datetime', 'lat', 'lon', 'alt','FlightYawDegree', 'FlightPitchDegree','FlightRollDegree', 'GimbalYawDegree','GimbalPitchDegree','GimbalRollDegree','flycState'])
        self.interpolated_df=df_interpolated
        return df_interpolated

    def sync_log_files(self):
        assert self.interpolated_df is not None 
        # and  self.log_file_row_index is not None and len(self.srt_files)>0
        interpolated_df= self.interpolated_df
        srt_dfs=[]
        done=False
        for i,srt_file in enumerate(self.srt_files):
            if(i==0):
                srt_df= srt_file[srt_file['fn'].astype(np.int64) >= self.frame_index].copy()
                #Find where in the interpolated log file the first position matches up with
                interpolated_index=np.where(interpolated_df['time']==self.logdf.iloc[self.log_file_row_index]['time(millisecond)'])[0].item()
                
            else:
                srt_df=srt_file
            yaw_flight=interpolated_df.iloc[interpolated_index: interpolated_index+len(srt_df)]['FlightYawDegree'].to_numpy()
            pitch_flight=interpolated_df.iloc[interpolated_index: interpolated_index+len(srt_df)]['FlightPitchDegree'].to_numpy()
            roll_flight= interpolated_df.iloc[interpolated_index: interpolated_index+len(srt_df)]['FlightRollDegree'].to_numpy()

            yaw_gimbal=interpolated_df.iloc[interpolated_index: interpolated_index+len(srt_df)]['GimbalYawDegree'].to_numpy()
            pitch_gimbal=interpolated_df.iloc[interpolated_index: interpolated_index+len(srt_df)]['GimbalPitchDegree'].to_numpy()
            roll_gimbal= interpolated_df.iloc[interpolated_index: interpolated_index+len(srt_df)]['GimbalRollDegree'].to_numpy()

            flycstate= interpolated_df.iloc[interpolated_index: interpolated_index+len(srt_df)]['flycState'].to_list()


            # Dont use any data that is not taken from the correct gimbal angle or if the Go Home signal was initiated
            if(len(np.where(((pitch_gimbal-self.target_gimbal ) > 1.5)  | (np.array(flycstate)=='Go_Home'))[0])>0):
                index=np.where((np.abs(pitch_gimbal-self.target_gimbal ) > 1.5)  | (np.array(flycstate)=='Go_Home'))[0][0].item()
                srt_df= srt_df[0: index].copy()
                # yaw=yaw[0:index]
                # pitch=pitch[0:index]
                # roll=roll[0:index]
                # flycstate=flycstate[0:index]
                done=True
            srt_df['f_yaw']=yaw_flight[:len(srt_df)]
            srt_df['f_pitch']=pitch_flight[:len(srt_df)]
            srt_df['f_roll']=roll_flight[:len(srt_df)]


            srt_df['g_yaw']=yaw_gimbal[:len(srt_df)]
            srt_df['g_pitch']=pitch_gimbal[:len(srt_df)]
            srt_df['g_roll']=roll_gimbal[:len(srt_df)]

            srt_df['flycState'] =flycstate[:len(srt_df)]
            
            srt_dfs.append(srt_df)
            if(done): 
                break
            interpolated_index += len(srt_df)
        self.srt_dfs=srt_dfs
        return srt_dfs

        
    def geotag_video(self, output_path=None):
        '''
        Given the frame by frame SRT dataframes that contain all the information, turn into a json file that can be exported

        Args:
            output_path (str): Output json file path
        '''
        self.interpolate_rotation_angles()
        self.sync_log_files()
        output={}
        for i,df in enumerate(self.srt_dfs):
            for column in df.columns:
                try:
                    df[column] = pd.to_numeric(df[column])
                except ValueError as e:
                    df[column]=df[column].astype(str)
                except Exception as e:
                    print(e)

            output[self.video_names[i]]={}
            df=df.set_index('fn')
            dictionary= df.to_dict(orient='index')
            output[self.video_names[i]]['Frames'] = dictionary
        self.json=output
        if(output_path is not None):
            with open(output_path,'w') as f:
                json.dump(output,f)


    def extract_frames(self, sampling_rate, output_dir, portrait=True, CameraModel="FC8482",Template = "Template/DJI_0419.JPG"):
        '''
        Given that each frame of the videos has been geotagged, we can now extract frames from the videos associated with this log file and prepare them in a format accepted by photometry software
        For this we need to have provided video_dir when instantiating the object


        Args:
            sampling_rate (int): how often to extract frames from the video
            output_dir (str): Where to store the frames
            portrait (bool): If the video was shot in portrait we have to rotate the image before saving as cv2 does not 
            CameraModel (str): String describing the camera model, useful for downstream tasks 
            Template (str): Path to a template JPG (ideally an image taken from the same drone the video is from) to copy metadata fields from
        '''
        # if(not os.path.exists(output_dir)):
        Path(output_dir).mkdir(parents=True, exist_ok=True)
                  # â† your reference photo

        # ExifTool returns JSON when you pass -j
        raw = subprocess.check_output(["exiftool", "-j", "-All", Template])
        for video, df, video_name in zip(self.video_paths,self.srt_dfs, self.video_names):
            cap = cv2.VideoCapture(video)
            fps = cap.get(cv2.CAP_PROP_FPS)  

            cap.set(cv2.CAP_PROP_POS_FRAMES, np.min(df['fn'])-1)
            frame_idx= np.min(df['fn'])
            i=0
            with tqdm(total=np.max(df['fn'])-np.min(df['fn'])) as pbar:
                while cap.isOpened():
                    ret, frame = cap.read()
                    if(portrait):
                        frame=cv2.rotate(frame, cv2.ROTATE_90_COUNTERCLOCKWISE)
                
                    if not ret:
                        break
                    out_path = os.path.join(output_dir, f"{video_name}_{frame_idx:06d}.jpg")
                    if(i%sampling_rate==0):
                        cv2.imwrite(out_path, frame)
                        row=df[df['fn']==frame_idx].iloc[0]
                        dt_str=str(row['timestamp'])
                        GPSLatRef= "N" if row['latitude']>=0 else 'S'
                        GPSLonRef= "E" if row['longitude']>=0 else 'W'

                        dms_lat= to_dms_rational(row['latitude'])
                        GPSLat= f"{dms_lat[0][0]} deg {dms_lat[1][0]} ' {dms_lat[2][0]/dms_lat[2][1]}" +f'" {GPSLatRef}'

                        dms_lon= to_dms_rational(row['longitude'])
                        GPSLon= f"{dms_lon[0][0]} deg {dms_lon[1][0]} ' {dms_lon[2][0]/dms_lon[2][1]}" +f'" {GPSLonRef}'


                        subprocess.check_output([
                            "exiftool", "-overwrite_original", "-F",
                            "-TagsFromFile", Template,
                            f"-Model={CameraModel}",
                            f"-DateTimeOriginal={dt_str}",
                            f"-CreateDate={dt_str}",
                            f"-FNumber={str(row['fnum'])}",
                            f"-RelativeAltitude={row['rel_alt']}",
                            f"-GimbalRollDegree={row['g_roll']}",
                            f"-GimbalYawDegree={row['g_yaw']}",
                            f"-GimbalPitchDegree={row['g_pitch']}",
                            f"-FlightRollDegree={row['f_roll']}",
                            f"-FlightYawDegree={row['f_yaw']}",
                            f"-FlightPitchDegree={row['f_pitch']}",
                            f"-GPSLatitudeRef={GPSLatRef}",
                            f"-GPSLongitudeRef={GPSLonRef}",
                            f'-GPSLatitude="{GPSLat}"',
                            f'-GPSLongitude="{GPSLon}"',
                            f"-GPSAltitude={float(row['abs_alt'])}",
                            f"-AbsoluteAltitude={float(row['abs_alt'])}",
                            out_path
                        ])                    
                    i += 1                
                    frame_idx+=1
                    pbar.update(1)



def preprocess_args(args):
    if(args.SaveJson):
        if(args.JsonPath is None):
            json_path= os.path.join(os.path.dirname(args.LogFile), os.path.splitext(os.path.basename(args.LogFile))[0] + ".json")
        else:
            json_path=args.JsonPath
    else:
        json_path=None
    
    args.JsonPath=json_path


    if(args.SaveFrames):
        if(args.VideoDir is None):
            raise RuntimeError("To save frames input a video directory")
        if(args.FrameDirectory is None):
            args.FrameDirectory= os.path.join(os.path.dirname(args.LogFile), os.path.splitext(os.path.basename(args.LogFile))[0] + "_frames/")


    return args
def main(args):
    if(args.SRTDir is not None):
        gt= GeoTagger(args.LogFile, args.SRTDir, frame_index=args.FrameIndex, video_dir=args.VideoDir)
    elif(args.SRTPaths is not None):
        gt= GeoTagger(args.LogFile, args.SRTPaths, frame_index=args.FrameIndex, video_dir=args.VideoDir)
    else:
        raise RuntimeError("Either an SRT dir or SRT paths must be provided")
    

    gt.geotag_video(args.JsonPath)

    if(args.SaveFrames):
        gt.extract_frames(args.SamplingRate, args.FrameDirectory, args.Portrait, args.CameraModel, args.Template)

def get_parser():
    parser= ArgumentParser()

    parser.add_argument("LogFile", help="Path to the log file corresponding to the flight", type=str)
    parser.add_argument("--SRTDir",help="Path to a directory containing the SRT files to parse", type=str)
    parser.add_argument("--SRTPaths", help="Space seperated list of paths to SRT files", nargs="+")
    parser.add_argument("--FrameIndex", help="Number of frames to skip in first video of log file (if the video contains pitching down motion)", type=int, default=1)
    parser.add_argument("--VideoDir", help="Path to directory containing videos corresponding to SRT files required for extracting frames", type=str)
    parser.add_argument("--SaveJson", help="If to save results in json format", action='store_true', default=False)
    parser.add_argument("--JsonPath", help="Path to save json to leave blank for default save", type=str)
    parser.add_argument("--SaveFrames", help="If to save the frames of the video individually", action='store_true', default=False)
    parser.add_argument("--FrameDirectory", help="Directory to save frames to",  type=str)

    parser.add_argument("--SamplingRate", help="Sampling rate to save frames at", type=int, default=100)

    parser.add_argument("--Portrait", help="If video was shot in portrait", action="store_true", default=False)
    parser.add_argument("--CameraModel", help="Camera model of drone (useful for downstream photometry tasks)", type=str, default="FC8482")
    parser.add_argument("--Template", help="Template jpg file to copy metadata from", type=str, default="../Template/DJI_0419.JPG")

    return parser



if __name__=="__main__":
    parser = get_parser()
    args = parser.parse_args()

    args= preprocess_args(args)

    main(args)


